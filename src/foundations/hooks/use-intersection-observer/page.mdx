export const metadata = {
  title: "useIntersectionObserver",
  description:
    "A hook for observing the intersection of an element (or array of elements) with the viewport",
  files: [
    "src/foundations/hooks/use-intersection-observer/use-intersection-observer.ts",
  ],
};

## API Reference

<PropsTable
  definition={{
    ref: {
      type: "RefObject<HTMLElement | null> | RefObject<HTMLElement | null>[]",
      description: "The element(s) to observe.",
      required: true,
    },
    options: {
      type: "{ threshold?: number | number[], root?: RefObject<HTMLElement | null> | null, rootMargin?: string }",
      description: "The options to pass to the IntersectionObserver.",
    },
    callback: {
      type: "(isIntersecting: boolean, entry?: IntersectionObserverEntry) => void",
      description: "The callback to call when the element(s) intersect.*",
    },
  }}
/>

The hook returns a reactive object with `isIntersecting` (`boolean`) and `entry` (`IntersectionObserverEntry`) properties **when no callback is provided**. This provides flexibility in handling intersection events - you can either react to changes declaratively using the returned state, or use the callback for more performant, render-independent updates.

## Examples

### Basic

```tsx
const Example = () => {
  const ref = useRef(null);
  const { isIntersecting } = useIntersectionObserver(ref);

  return (
    <div ref={ref}>
      {isIntersecting ? "Element is visible" : "Element is hidden"}
    </div>
  );
};
```

### As Callback

```tsx
const Example = () => {
  const ref = useRef(null);

  useIntersectionObserver(ref, { threshold: 0.5 }, (isIntersecting) => {
    if (isIntersecting) {
      window.dataLayer?.push({ event: "elementVisible" });
    }
  });

  return <div ref={ref}>Element</div>;
};
```

### Multiple Elements

```tsx
const Example = () => {
  const blocks = useRef([]);
  const viewedObservables = useRef([]);

  useIntersectionObserver(
    blocks.current,
    { threshold: 1 },
    (isIntersecting, entry) => {
      if (isIntersecting) {
        const uniqueObservables = new Set(viewedObservables.current);
        uniqueObservables.add(entry?.target);

        viewedObservables.current = Array.from(uniqueObservables);
      }
    }
  );

  return (
    <main>
      {blocks.map((block) => (
        <div
          key={block.id}
          ref={(element) => {
            if (block.observe && element) {
              block.ref = element;
            }
          }}
        >
          <DynamicBlock {...block} />
        </div>
      ))}
    </main>
  );
};
```
