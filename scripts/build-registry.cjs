const fs = require('fs');
const path = require('path');

const ROOT_DIRECTORY = 'src/';
const TARGET_DIRECTORY = '.registry';
const SOURCE_DIRECTORIES = ['components/foundations'];

// recursively get all files in directory
function getAllFiles(dir, depth = 0) {
  const MAX_RECURSIVE_DEPTH = 12;
  if (depth >= MAX_RECURSIVE_DEPTH) {
    console.warn(`Reached max recursive depth`);
    return [];
  }

  let files = [];
  const items = fs.readdirSync(dir, { withFileTypes: true });

  for (const item of items) {
    if (item.isDirectory()) {
      const children = getAllFiles(path.join(item.path, item.name), depth + 1);
      files = [...files, ...children];
    } else {
      files.push(item);
    }
  }

  return files;
}

function toPascalCase(str) {
  return str
    .replace(/(?:^|\s|-|_|\.)[a-zA-Z]/g, (match) => match.toUpperCase()) // capitalize first letter after space, dash, underscore, or dot
    .replace(/(?:\s|-|_|\.)/g, '') // remove spaces, dashes, underscores, and dots
    .replace(/[^a-zA-Z]/g, ''); // remove numbers and special characters
}

async function buildRegistry() {
  try {
    const startTime = performance.now();
    console.log('Building registry...');

    // clear/create target directory
    if (fs.existsSync(TARGET_DIRECTORY)) {
      fs.readdirSync(TARGET_DIRECTORY).forEach((filename) =>
        fs.rmSync(path.join(TARGET_DIRECTORY, filename))
      );
    } else {
      fs.mkdirSync(TARGET_DIRECTORY);
    }

    let files = [];
    const index = { filename: 'index.tsx', imports: [], entries: [] };

    // get all files (at any depth) inside the source directories
    for (const dir of SOURCE_DIRECTORIES) {
      const fullDir = path.join(ROOT_DIRECTORY, dir);

      if (fs.existsSync(fullDir)) {
        const children = getAllFiles(fullDir);
        files = [...files, ...children];
      } else {
        console.warn(`└ Skipping invalid source directory: '${dir}'`);
      }
    }

    for (const file of files) {
      const fullPath = path.join(file.path, file.name);
      const extension = path.extname(file.name).replace(/^\.+/, ''); // remove leading dot
      const basename = path.basename(file.name, `.${extension}`);
      const isComponent = extension === 'tsx';

      // skip index files
      if (basename === 'index') {
        continue;
      }

      let rawFileContent = fs.readFileSync(fullPath, 'utf8');
      rawFileContent = rawFileContent.replace(/\n$/, ''); // remove trailing line break

      const mdxContentString = `\`\`\`${extension} copy\n${rawFileContent}\n\`\`\`\n`;

      const mdxBasename = `${toPascalCase(basename)}Code`;
      const mdxFilename = `${mdxBasename}.mdx`;
      const mdxPath = path.join(TARGET_DIRECTORY, mdxFilename);

      // write mdx code file
      fs.writeFileSync(mdxPath, mdxContentString, 'utf8');

      // generate entry key based on import path
      let key = file.path.replace(ROOT_DIRECTORY, '');
      // append basename only if the last fragment of the import path is different from the basename
      // this way we avoid having keys like 'components/Sample/Sample'
      if (key.split('/').reverse()[0] !== basename) {
        key += `/${basename}`;
      }

      index.entries.push({ key, code: mdxBasename, component: isComponent && basename });
      index.imports.push({ module: mdxBasename, named: false, path: `./${mdxFilename}` });

      if (isComponent) {
        index.imports.push({ module: basename, named: true, path: `../${file.path}/${basename}` });
      }
    }

    const formattedImports = index.imports
      .map(
        ({ module, path, named }) => `import ${named ? `{ ${module} }` : module} from '${path}';`
      )
      .join('\n');

    const formattedEntries = index.entries
      .map(
        ({ key, code, component }) =>
          `  '${key}': {\n    code: ${code},\n    component: ${component}\n  }`
      )
      .join(',\n');

    const formattedEntryTypes = index.entries.map(({ key }) => `  | '${key}'`).join('\n');

    const indexContentString = [
      `// @ts-nocheck`,
      `// This file is autogenerated by scripts/mdx-code-files.ts`,
      `// Do not edit this file directly.`,
      formattedImports,
      ``,
      `export const INDEX = {`,
      formattedEntries,
      `};`,
      ``,
      `export type RegistryEntry =`,
      `${formattedEntryTypes};`,
      ``
    ].join('\n');

    // write index.tsx
    fs.writeFileSync(path.join(TARGET_DIRECTORY, index.filename), indexContentString, 'utf8');

    const duration = performance.now() - startTime;
    console.log(`└ Wrote (${files.length + 1} files in ${duration.toFixed(3)}ms)`);
  } catch (err) {
    console.error(err);
  }
}

const args = process.argv.slice(2);
if (args.indexOf('--run') !== -1) {
  buildRegistry();
}

module.exports = {
  SOURCE_DIRECTORIES,
  buildRegistry
};
