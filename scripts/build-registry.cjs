const fs = require('fs');
const path = require('path');
const { globSync } = require('glob');

const ROOT_DIRECTORY = 'src/';
const TARGET_DIRECTORY = '__registry__';
const SOURCE_GLOB_PATTERNS = [
  'src/components/foundations/**/*.{js,ts,tsx}',
  'src/lib/tailwind.ts',
  'tailwind.config.cjs'
];

function toPascalCase(str) {
  return str
    .replace(/(?:^|\s|-|_|\.)[a-zA-Z]/g, (match) => match.toUpperCase()) // capitalize first letter after space, dash, underscore, or dot
    .replace(/(?:\s|-|_|\.)/g, '') // remove spaces, dashes, underscores, and dots
    .replace(/[^a-zA-Z]/g, ''); // remove numbers and special characters
}

// the nextra code highlighter doesn't support certain extension variants
const EXTENSION_ALTERNATES = {
  cjs: 'js',
  mjs: 'js'
};

async function buildRegistry() {
  try {
    const startTime = performance.now();
    console.log('Building registry...');

    // clear target directory
    if (fs.existsSync(TARGET_DIRECTORY)) {
      fs.rmSync(TARGET_DIRECTORY, { recursive: true });
    }

    // create target directory
    fs.mkdirSync(TARGET_DIRECTORY);

    // read all files
    const files = SOURCE_GLOB_PATTERNS.flatMap((pattern) =>
      globSync(pattern, {
        withFileTypes: true,
        ignore: {
          ignored: (p) => /^index\.(js|ts)$/.test(p.name) // ignore index files
        }
      })
    );

    // prepare registry index
    const index = {
      filename: 'index.tsx',
      imports: [],
      entries: []
    };

    for (let i = 0; i < files.length; i++) {
      const file = files[i];

      let extension = path.extname(file.name);
      const basename = path.basename(file.name, extension);
      const fullPath = path.relative(process.cwd(), path.join(file.parentPath, file.name));

      extension = extension.replace(/^\.+/, ''); // remove leading dot;
      const isComponent = extension === 'tsx';

      let rawFileContent = fs.readFileSync(fullPath, 'utf8');
      rawFileContent = rawFileContent.replace(/\n$/, ''); // remove trailing line break

      const mdxContentString = `\`\`\`${EXTENSION_ALTERNATES[extension] || extension} copy\n${rawFileContent}\n\`\`\`\n`;

      const mdxBasename = `${toPascalCase(basename)}Code${i}`; // append loop index to prevent files with same basename being overwritten
      const mdxFilename = `${mdxBasename}.mdx`;
      const mdxPath = path.join(TARGET_DIRECTORY, mdxFilename);

      // write mdx code file
      fs.writeFileSync(mdxPath, mdxContentString, 'utf8');

      // generate entry key based on import path
      let key = path.relative(ROOT_DIRECTORY, file.parentPath);

      if (!isComponent) {
        // for non-component files the key is the full name
        // sample.js -> sample.js
        key = path.join(key, file.name);
      } else if (path.basename(key) !== basename) {
        // for components, we append the basename only when it's not the same as the path basename
        // components/Sample/Sample.tsx -> components/Sample
        key = path.join(key, basename);
      }

      // remove leading '../' that gets added to root files
      if (key.indexOf('../') === 0) {
        key = key.substring(3);
      }

      index.entries.push({ key, code: mdxBasename, component: isComponent ? basename : null });
      index.imports.push({ module: mdxBasename, named: false, path: `./${mdxFilename}` });

      if (isComponent) {
        index.imports.push({
          module: basename,
          named: true,
          path: `../${fullPath}`
        });
      }
    }

    const formattedImports = index.imports
      .map(({ module, path, named }) => {
        return `import ${named ? `{ ${module} }` : module} from '${path}';`;
      })
      .join('\n');

    const formattedEntries = index.entries
      .map(({ key, code, component }) => {
        return `'${key}': { code: ${code}, component: ${component} }`;
      })
      .join(',\n');

    const formattedEntryTypes = index.entries.map(({ key }) => `  | '${key}'`).join('\n');

    const indexContentString = [
      `// @ts-nocheck`,
      `// This file is autogenerated by scripts/mdx-code-files.ts`,
      `// Do not edit this file directly.`,
      formattedImports,
      ``,
      `export const INDEX = {`,
      formattedEntries,
      `};`,
      ``,
      `export type RegistryEntry =`,
      `${formattedEntryTypes};`,
      ``
    ].join('\n');

    // write index.tsx
    fs.writeFileSync(path.join(TARGET_DIRECTORY, index.filename), indexContentString, 'utf8');

    const duration = performance.now() - startTime;
    console.log(`â”” Wrote (${index.entries.length + 1} files in ${duration.toFixed(3)}ms)`);
  } catch (err) {
    console.error(err);
  }
}

const args = process.argv.slice(2);
if (args.indexOf('--run') !== -1) {
  buildRegistry();
}

module.exports = {
  buildRegistry
};
